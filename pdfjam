#!/bin/sh
version=N.NN
#########################################################################
##                                                                     ##
##  pdfjam: A shell-script interface to the "pdfpages" LaTeX package   ##
##  ------                                                             ##
##                                                                     ##
##  Author: David Firth (https://warwick.ac.uk/dfirth)                 ##
##  Maintainer: Markus Kurtz                                           ##
##                                                                     ##
##  Usage: see https://github.com/pdfjam/pdfjam                      ##
##         or "pdfjam --help"                                          ##
##                                                                     ##
##  Relies on:                                                         ##
##  -- pdflatex (or xelatex or lualatex)                               ##
##  -- the 'pdfpages' package for LaTeX (ideally version >= 0.4f)      ##
##                                                                     ##
##  License: GPL version 2 or later.  This software comes with         ##
##  ABSOLUTELY NO WARRANTY of fitness for any purpose at all; if you   ##
##  do not accept that, then you must not use it.                      ##
##                                                                     ##
##  The path searched for site-wide configuration files can be set     ##
##  by editing the following variable:                                 ##
##                                                                     ##
    configpath='/etc:/usr/share/etc:/usr/local/share:/usr/local/etc'   ##
##                                                                     ##
##  Nothing else in this file should need to be changed.               ##
##                                                                     ##
#########################################################################
##
##  PRELIMINARIES
##
##  First determine:
##    --- whether verbose commentary should be provided (not if --quiet
##        or --configpath was specified);
##    --- whether this call to pdfjam is a "batch" call;
##    --- whether just the help text is required;
##    --- or whether all configuration files should be ignored.
##
verbose=true
for arg; do
	case $arg in
	--quiet | -q | --configpath)
		verbose=false;;
	--version | -V)
		echo "$version"
		exit 0;;
	--batch)
		batch=true;;
	--vanilla)
		vanilla=true;;
	*) ;;
	esac
done
##
##  Check to see whether this is a "secondary" call to pdfjam:
##
if test -z "$PDFJAM_CALL_NUMBER"; then ## not a secondary call
	PDFJAM_CALL_NUMBER=0
fi
##
##  Keep a copy of the internal file separator, so we can change it safely
##
OIFS="$IFS"
##
##  Record the full filename of the current working directory
##
pwd=$(pwd)
##
##  Trap interrupts so that they kill everything:
##
trap 'IFS=$OIFS; exit 1' HUP INT TERM
##
##  The following will be useful for readability of the script:
##
newline='
'
##
##  Functions to massage input
##
##  Use '' to escape string with multiple tricky characters and \ otherwise
enquote() {
	case "$1" in
	*$newline*) printf %s "$1" >&2; escape_quote "$1" ;;
	'' | *)
		if printf %s "$1"|grep -Eq '([	 !"#$&()*<>?\^`{|}~].*){2}'; then
			escape_quote "$1"  ##    ^-- matched twice due to --^
		else
			escape_chars "$1"
		fi
	esac
}
escape_quote() {  ## Put everything in '' and care for actual '
	printf %s "'$(printf %s "$1" | sed "s/'/'\\\\''/g")'"
}
escape_chars() {  ## Prefix tricky characters with \
	printf %s "$1" | sed 's/[	 !"#$&-*;<>?[-^`{|}~]/\\&/g'
}
##  Put argument in {} if necessary for parsing inside a key value list
embrace() {
	value="$1"
	case "$value" in
	\{*\}) ;;
	*,* | *\]*) value="{$value}" ;;
	esac
	printf %s "$value"
}
##  Strip legacy surrounding {}; add bp if no units given
to_papersize() {
	value="$1"
	case "$value" in
		\{*\}) value="${value#\{}"; value="${value%\}}"
	esac
	printf %s "$value" | sed -E 's/([0-9]{1,}\.{0,1}[0-9]*)(,|$)/\1bp\2/g'
}
##
##  Define a function to output verbose comments:
##
prattle() { ## second argument here is non-null for continuation lines
	if test $verbose = true; then
		prefix1="  pdfjam:"
		prefix2=$(printf "%s" "$prefix1" | sed 's/pdfjam:/       /')
		indent=""
		if test "$PDFJAM_CALL_NUMBER" -gt 0 && test "$batch" != true; then
			indent="    "
		fi
		IFS="$newline"
		lineCounter=0
		for line in ${1}; do
			lineCounter=$((lineCounter + 1))
			if test $lineCounter -eq 1 && test ! -n "${2}"; then
				if test -w "$PDFJAM_MESSAGES_FILE"; then
					printf "$prefix1$indent %s\n" "$line" >> \
						"$PDFJAM_MESSAGES_FILE"
				else
					messages="$messages$prefix1$indent $line$newline"
					## msg file not made yet
				fi
			else
				if test -w "$PDFJAM_MESSAGES_FILE"; then
					printf "$prefix2$indent %s\n" "$line" >> \
						"$PDFJAM_MESSAGES_FILE"
				else
					messages="$messages$prefix2$indent $line$newline"
					## msg file not made yet
				fi
			fi
		done
		IFS="$OIFS"
	fi
	return
}
##
##  And here's the first piece of verbose commentary:
##
prattle "----" 1
prattle "This is pdfjam version ${version}."
##
#########################################################################
##
##  CONFIGURATION
##
##  THESE SETTINGS WILL BE OVERRIDDEN by any found in configuration
##  files.  By default such files are found at any or all of
##     /etc/pdfjam.conf
##     /usr/share/etc/pdfjam.conf
##     /usr/local/share/pdfjam.conf
##     /usr/local/etc/pdfjam.conf
##     $HOME/.pdfjam.conf
##  (And they are read in that order; if a setting is made more than
##  once, the last instance prevails.)
##
##  An example configuration file can be found at
##     https://github.com/pdfjam/pdfjam
##
##  The path searched for site-wide configuration files can be changed
##  by editing the variable 'configpath' at the top of this file.
##
##
##  First get the full path (if it exists) to pdflatex:
##
latex=$(command -v pdflatex)
if [ -z "$latex" ]; then latex="not found"; fi
##
##  Likewise for the pdfinfo and iconv (only needed for `--keepinfo'):
##
pdfinfo=$(command -v pdfinfo)
if [ -z "$pdfinfo" ]; then pdfinfo="not found"; fi
iconv=$(command -v iconv)
if [ -z "$iconv" ]; then iconv="not found"; fi
##
##
##  Defaults
##
outFile="$pwd"      ##  Output to the current working directory
suffix=pdfjam       ##  Default filename suffix to be used when
##                      --outfile is either (a) a directory, or (b)
##                      not specified in a --batch call.
checkfiles=         ##  Don't use the Unix 'file -Lb' utility to
##                      identify PDF files from their contents;
##                      rely on the .pdf or .PDF extension instead.
keepinfo=           ##  Don't try to preserve "pdfinfo" data
landscape=          ##  Use portrait./Do not switch width and height.
twoside=            ##  No "twoside" option to documentclass
tidy=tidy           ##  Delete all temporary files at the end
runs=1              ##  Run latex just once
build_dir=          ##  Directory to use instead of temporary one
enc=                ##  Have `iconv` guess command line encoding
preamble=           ##  Default LaTeX preamble string.
##  END OF SETTINGS MADE DIRECTLY WITHIN THE SCRIPT
##
##  Now read the site's or user's configuration file(s) if such exist,
##  unless '--vanilla' was specified.
##
if test "$vanilla" != true; then
	if test "$PDFJAM_CALL_NUMBER" = 0; then ## not a secondary call to pdfjam
		configFiles=$(printf "%s" "$configpath" |
			sed 's/:/\/pdfjam.conf:/g; s/$/\/pdfjam.conf/')
		configFiles="${configFiles}:$HOME/.pdfjam.conf"
		PDFJAM_CONFIG=""
		prattle "Reading any site-wide or user-specific defaults..."
		IFS=':'
		for d in $configFiles; do
			if test -f "$d"; then
				change=$(sed '/^ *#.*/d ; s/ *#.*//; s/^ *//' "$d")
				comment="## ${newline}## From ${d}: ${newline}##"
				PDFJAM_CONFIG="$PDFJAM_CONFIG$comment$newline$change$newline"
			fi
		done
		IFS="$OIFS"
		PDFJAM_CONFIG=$(printf "%s" "$PDFJAM_CONFIG" | sed 's/^/    /')
		if test "$batch" = true; then export PDFJAM_CONFIG; fi
		if test -z "$PDFJAM_CONFIG"; then
			prattle "(none found)" 1
		else
			prattle "$PDFJAM_CONFIG" 1
		fi
	fi
	if test -n "$PDFJAM_CONFIG"; then eval "$PDFJAM_CONFIG"; fi
else
	if test "$PDFJAM_CALL_NUMBER" -eq 0; then
		prattle "Called with '--vanilla': no user or site configuration"
		prattle "files will be read." 1
	fi
fi
## For backwards compatibility, check here for a $pdflatex setting in the config file
if [ -n "${pdflatex:-}" ]; then latex="$pdflatex"; fi
##
##  If paper size is not set, get default paper size from libpaper if
##  possible, otherwise guess A4.
##
paperformats=:a0:a1:a2:a3:a4:a5:a6:b0:b1:b2:b3:b4:b5:b6:c0:c1:c2:c3:c4:c5:c6\
:ansia:ansib:ansic:ansid:ansie:letter:legal:executive:b0j:b1j:b2j:b3j:b4j:b5j:b6j:
to_paper() {
	printf %s "$1"|grep -q '^[A-Za-z0-9]*$' || return 2 # make sure input is harmless
	paper=$(echo "$1" | tr A-Z a-z)
	paper=${paper%paper}
	echo $paperformats|grep -q ":$paper:" || return 1
	case $paper in
	b?j) ;;
	*) paper="$paper"paper
	esac
	echo "$paper"
}
paperspec=
if test -z "$paper"; then
	if command -v paper >/dev/null; then  ## provided by libpaper>=2
		paperspec=$(paper)
		if echo "$paperspec" | grep -q ': '; then
			if ! paper=$(to_paper "${paperspec%%: *}"); then
				paperdimensions=$(echo "$paperspec" | cut -f 2 -d " ")
				paperunit=$(echo "$paperspec" | cut -f 3 -d " ")
				if test "$paperunit" = "pt"; then paperunit=bp; fi
				paperwidth=$(echo "$paperdimensions" | cut -f 1 -d "x")
				paperheight=$(echo "$paperdimensions" | cut -f 2 -d "x")
				papersize="$paperwidth$paperunit,$paperheight$paperunit"
			fi
		else
			echo "The 'paper' program seems not to be working; not using it"
		fi
	fi
	if test -z "$paper$papersize"; then
		if command -v paperconf >/dev/null; then  ## provided by libpaper>=1
			if ! paper=$(to_paper "$(paperconf)"); then
				papersize=$(paperconf -s|sed -E 's/(.*) (.*)/\1bp,\2bp/')
			fi
		else
			paper='a4paper' ## fallback paper size is ISO A4
			papersize=''    ## clear papersize
		fi
	fi
fi
##
##  END OF CONFIGURATION BLOCK
##
#########################################################################
##
##  HELP TEXT
##
##  Defines the output of 'pdfjam --help'
##
helptext="
insert contents of pdfjam-help.txt here
"
##
##  END OF HELP TEXT
##
#########################################################################
#
# If --help is given, print help and exit. We do this here so that the
# configuration files have already been read, and default values can be
# shown in the help
for arg; do
	case $arg in
	--help | -u | -h)
		printf "%s\n" "$helptext"
		exit 0;;
	*) ;;
	esac
done
#########################################################################
##
##  ERROR CODES
##
E_USAGE=64           #  command line usage error
E_NOINPUT=66         #  cannot open input
E_UNAVAILABLE=69     #  service unavailable
E_SOFTWARE=70        #  internal software error
E_OSFILE=72          #  file does not exist or cannot be opened
E_CANTCREATE=73      #  can't create (user) output file
E_CONFIG=78          #  configuration error
##
##  Define a function to print an error message and exit:
##
error_exit() {
	if [ -r "$PDFJAM_MESSAGES_FILE" ]; then
		cat "$PDFJAM_MESSAGES_FILE" >&2
	else
		printf "%s" "$messages" 1>&2
	fi
	printf "  pdfjam ERROR: %s\n" "$1" 1>&2
	exit "$2"
}
##
#########################################################################
##
##  READ AND PROCESS THE ARGUMENTS
##
##  In case of NO argument supplied, mention 'pdfjam --help':
##
if test $# -eq 0; then
	prattle "No arguments supplied; continuing anyway. (See"
	prattle "'pdfjam --help' for information on usage.)" 1
fi
##
##  Now do the argument loop.
##
fileSpec=""
miscOptions=""
callOptions=""
optionsFinished=""
##
##  First note any '--checkfiles' or '--no-checkfiles' option
##
for arg; do
	case $arg in
	--checkfiles)
		checkfiles=checkfiles
		callOptions="$callOptions $1";;
	--no-checkfiles)
		checkfiles=
		callOptions="$callOptions $1";;
	esac
done
while test -n "$1$2"; do
	argUnmatched=""
	if test "$optionsFinished" != true; then
		case "$1" in
		--) ## signals end of command-line options
			optionsFinished=true
			shift
			continue
			;;
		--configpath)
			printf "%s\n" "$configpath"
			exit 0
			;;
		--* | -q | -o)
			if test "$pageSpecAwaited" = true; then
				## fill in any missing page specs before continuing
				fileSpec=$(printf "%s" "$fileSpec" | sed 's/|awaited/|-/g')
				pageSpecAwaited=false
			fi
			case "$1" in
			--checkfiles | --no-checkfiles | --batch) ;;  ## already done above
			--vanilla)
				callOptions="$callOptions $1"
				;;
			--quiet | -q)
				verbose=false
				callOptions="$callOptions --quiet"
				;;
			--outfile | -o)
				outFile="$2"
				callOptions="$callOptions --outfile $(enquote "$2")"
				shift
				;;
			--suffix)
				if test -n "$2"; then
					suffix="$2"
					callOptions="$callOptions $1 $(enquote "$2")"
					shift
				else
					error_exit \
						"'--suffix' string has zero length" \
						$E_USAGE
				fi
				;;
			--runs)
				runs="$2"
				## check if the argument is a number > 0
				if [ "$runs" -lt 1 ] 2>/dev/null; then
					error_exit \
						"'--runs' number must be at least 1" \
						$E_USAGE
				fi
				callOptions="$callOptions $1 $2"
				shift
				;;
			--paper)
				if ! paper=$(to_paper "$2"); then
					paper="$2"
					prattle "Paper '$paper' unknown to pdfjam."
				fi
				papersize=''
				callOptions="$callOptions $1 $(enquote "$paper")"
				shift
				;;
			--a?paper | --b?paper | --c?paper | --ansi?paper | \
			--letterpaper | --legalpaper | --executivepaper | \
			--b0j | --b1j | --b2j | --b3j | --b4j | --b5j | --b6j)
				paper=$(to_paper "${1#--}") \
					|| error_exit "Bad paper option '$1'." $E_USAGE
				papersize=''
				callOptions="$callOptions --paper $paper"
				;;
			--papersize)
				paper=''
				papersize=$(to_papersize "$2")
				callOptions="$callOptions $1 $(enquote "$papersize")"
				shift
				;;
			--preamble)
				preamble="$preamble$newline$2"
				shift
				;;
			--latex | --build-dir | --enc | --pagecolor | \
			--pdftitle | --pdfauthor | --pdfsubject | --pdfkeywords)
				eval "$(echo "${1#--}"|tr - _)='$2'"
				callOptions="$callOptions $1 $(enquote "$2")"
				shift
				;;
			--tidy | --keepinfo | --landscape | --twoside | --other-edge)
				option=$(echo "${1#--}"|tr - _)
				eval "$option=$option"
				callOptions="$callOptions $1"
				;;
			--no-tidy | --no-keepinfo | --no-landscape | --no-twoside | \
			--no-other-edge)
				eval "$(echo "${1#--no-}"|tr - _)="
				callOptions="$callOptions $1"
				;;
			--longedge)  ##  legacy
				other_edge=other_edge
				callOptions="$callOptions --other-edge"
				;;
			--shortedge)  ##  legacy
				other_edge=
				callOptions="$callOptions --no-other-edge"
				;;
			--*) ##  miscellaneous options for \includepdfmerge
				miscOptions="$miscOptions,${1#--}=$(embrace "$2")"
				callOptions="$callOptions ${1} $(enquote "$2")"
				shift
				;;
			esac
			;;
		'' | *)
			argUnmatched=true
			;;
		esac
	fi
	if test "$optionsFinished" = true || test "$argUnmatched" = true; then
		case "$1" in
		"" | /dev/stdin)
			fileSpec="$fileSpec$newline/dev/stdin|awaited"
			pageSpecAwaited=true
			inputFromStdin=true
			;;
		-)
			if test "$pageSpecAwaited" = true; then
				fileSpec=$(printf %s "$fileSpec" | sed 's/|awaited/|-/g')
				pageSpecAwaited=false
			else
				error_exit "no PDF/JPG/PNG file found at ${1}" \
					$E_NOINPUT
			fi
			;;
		*) ##  All other args should be PDF (or JPG/PNG)
			##  source files and page selections; if not, we'll quit
			if test -n "$checkfiles"; then ## not always available
				case $(file -Lb -- "$1") in
				"PDF document"* | "JPEG image data"* | "PNG image"*)
					##  it's a PDF file (or JPG/PNG) as expected
					fileSpec="$fileSpec$newline$1|awaited"
					pageSpecAwaited=true
					;;
				*)
					case ${1} in
					*.[pP][dD][fF] | *.[jJ][pP][eE][gG] | \
						*.[jJ][pP][gG] | *.[pP][nN][gG])
						## should be PDF/JPG/PNG file, but isn't
						error_exit "no PDF/JPG/PNG file found at ${1}" \
							$E_NOINPUT
						;;
					*) ##  if page spec needed, assume this is it;
						##  otherwise something is wrong
						if test "$pageSpecAwaited" = true; then
							escapedFilePath=$(printf '%s' "$1" | sed -e 's#/#\\/#g')
							fileSpec=$(printf "%s" "$fileSpec" \
								| sed "s/|awaited/|${escapedFilePath}/g")
							pageSpecAwaited=false
						else
							error_exit "no PDF/JPG/PNG file found at ${1}" \
								$E_NOINPUT
						fi
						;;
					esac
					;;
				esac
			else ## no checking of file contents; rely on .pdf extension
				case ${1} in
				*.[pP][dD][fF] | *.[jJ][pP][eE][gG] | \
					*.[jJ][pP][gG] | *.[pP][nN][gG])
					## assume it's a PDF/JPG/PNG file
					test -f "${1}" || error_exit \
						"${1} not found" $E_NOINPUT
					fileSpec="$fileSpec"$newline${1}"|"awaited
					pageSpecAwaited=true
					;;
				*) ##  if page spec needed, assume this is it;
					##  otherwise something is wrong
					if test "$pageSpecAwaited" = true; then
						escapedFilePath=$(printf '%s' "$1" | sed -e 's#/#\\/#g')
						fileSpec=$(printf "%s" "$fileSpec" \
							| sed "s/|awaited/|${escapedFilePath}/g")
						pageSpecAwaited=false
					else
						error_exit "no PDF/JPG/PNG file found at ${1}" \
							$E_NOINPUT
					fi
					;;
				esac
			fi
			;;
		esac
	fi
	shift
done
##
##  Use the default page spec for any that remain unspecified:
##
fileSpec=$(printf "%s" "$fileSpec" | sed '/^$/d; s/^ //; s/|awaited$/|-/')
##
##  Check whether input from stdin should be used by default:
if test "$PDFJAM_CALL_NUMBER" -eq 0 && test "$inputFromStdin" != true; then
	## the special argument '/dev/stdin' was not used
	if test -z "$fileSpec"; then
		## no argument specifying a PDF source was given
		inputFromStdin=true
		fileSpec="/dev/stdin|-"
		prattle "No PDF/JPG/PNG source specified: input is from stdin."
	fi
fi
## Massage options
[ "${paper:+set}" = "${papersize:+set}" ] && error_exit "Exactly one of \
\$paper='$paper' and \$papersize='$papersize' must be set." $E_SOFTWARE
miscOptions="${miscOptions#,}"
if test -n "$preamble"; then
	callOptions="$callOptions --preamble $(enquote "${preamble#$newline}")"
fi
callOptions="${callOptions# }"
if [ -n "$other_edge" ]; then
	other_edge='
{\makeatletter\AddToHook{shipout/before}{\ifodd\c@page\pdfpageattr{/Rotate 180}\fi}}'
fi
if [ -n "$papersize" ]; then
	if [ -n "$landscape" ]; then
		## geometry package ignores landscape, thus swap x,y → y,x manually
		papersize="${papersize#*,},${papersize%%,*}"
	fi
	papersize="papersize={$papersize}"
fi

documentOptions=
for i in "$paper" "$landscape" "$twoside"; do
	[ -n "$i" ] && documentOptions="$documentOptions$i,"
done
##
##  END OF ARGUMENT PROCESSING
##
#########################################################################
##
##  CHECK SYSTEM SETUP
##
##  These checks are not repeated in secondary calls.
##
if test "$PDFJAM_CALL_NUMBER" -eq 0; then ## not a secondary call
	##  Check whether there's a suitable latex to use:
	case "$latex" in
	"not found")
		error_exit "can't find pdflatex!" $E_UNAVAILABLE
		;;
	*) ##
		if test ! -x "$latex"; then
			error_exit \
				"configuration error, $latex is not an executable file" \
				$E_CONFIG
		fi
		;;
	esac
	##
	##  Check that necessary LaTeX packages are installed:
	##
	modifyPath=$(printf "%s" "$latex" | sed 's/\/[^\/]*$//')
	if [ -n "$modifyPath" ]; then
		PATH="$modifyPath:$PATH"
		export PATH
	fi
	case "$latex" in
	*tectonic*) ;;
	*)
		(kpsewhich pdfpages.sty >/dev/null) \
			|| error_exit \
				"LaTeX package pdfpages.sty is not installed" \
				$E_UNAVAILABLE
		;;
	esac
fi
if test -n "$keepinfo"; then
	case "$pdfinfo" in
	"not found")
		if test "$PDFJAM_CALL_NUMBER" -eq 0; then
			prattle \
				"The pdfinfo utility was not found, so --keepinfo is ignored."
		fi
		keepinfo=
		;;
	pdfinfo) ;;
	*) ## $pdfinfo was set in a configuration file
		if test ! -x "$pdfinfo"; then
			if test "$PDFJAM_CALL_NUMBER" -eq 0; then
				prattle \
					"No pdfinfo utility at $pdfinfo, so --keepinfo is ignored."
				keepinfo=
			fi
		fi
		;;
	esac
	case "$iconv" in
	"not found")
		if test "$PDFJAM_CALL_NUMBER" -eq 0; then
			prattle \
				"The iconv utility was not found, so --keepinfo is ignored."
		fi
		keepinfo=
		;;
	iconv) ;;
	*) ## $iconv was set in a configuration file
		if test ! -x "$iconv"; then
			if test "$PDFJAM_CALL_NUMBER" -eq 0; then
				prattle \
					"No iconv utility at $iconv, so --keepinfo is ignored."
				keepinfo=
			fi
		fi
		;;
	esac
fi
using_non_cygwin_latex_from_cygwin() {
	if [ -z "${__cache__using_non_cygwin_latex_from_cygwin}" ]; then
		if uname | grep -q CYGWIN \
			&& "${latex}" -version | head -1 | grep -qv Cygwin; then
			__cache__using_non_cygwin_latex_from_cygwin=0
		else
			__cache__using_non_cygwin_latex_from_cygwin=1
		fi
	fi
	return "${__cache__using_non_cygwin_latex_from_cygwin}"
}
##
##  END OF CHECKING THE SETUP
##
#########################################################################
##
##  TEMPORARY FILES
##
##  Make a secure temporary directory (following
##  the autoconf manual).
##
##  Use mktemp if possible; otherwise fall back on mkdir,
##  with random name to make file collisions less likely.
##
if test "$PDFJAM_CALL_NUMBER" = 0; then ## don't repeat this work for secondary calls
	if test -z "$build_dir"; then
		PDFJAM_TEMP_DIR=''
		tidycode=$([ -n "$tidy" ] && echo ';cd "$pwd";rm -rf "$PDFJAM_TEMP_DIR"')
		trap "IFS='$OIFS'$tidycode;exit 1" HUP INT TERM
		trap "IFS='$OIFS'$tidycode" EXIT
		get_tempfile_dir() {
			for i in "$TMPDIR" "$TMP" /tmp /var/tmp .; do
				[ -d "$i" ] && [ -w "$i" ] && printf %s "$i" && return
			done
			return 1
		}
		tempfileDir="$(get_tempfile_dir)" || error_exit \
			'Cannot determine directory for temporary files.
		Fix your installation or provide --build-dir PATH.' $E_SOFTWARE
		##  Try mktemp. If this fails, portably make up a random number.
		PDFJAM_TEMP_DIR=$( (umask 077 && mktemp -d "$tempfileDir/pdfjam-XXXXXX") 2>/dev/null) \
			|| {
				random=$(awk 'END { srand(); printf ("%d\n", rand()*1000000); }' /dev/null)
				PDFJAM_TEMP_DIR="$tempfileDir/pdfjam$$-$random"
				(umask 077 && mkdir "$PDFJAM_TEMP_DIR")
			} && [ -d "$PDFJAM_TEMP_DIR" ] && [ -w "$PDFJAM_TEMP_DIR" ] \
			|| error_exit 'Failed to create a temporary directory.
		Fix your installation or provide --build-dir PATH.' $E_SOFTWARE
		if [ -z "$tidy" ]; then
			prattle "Temporary directory for this job is
          $PDFJAM_TEMP_DIR"
		fi
	else
		tidy=  ##  used in error message
		(umask 077 && mkdir -p "$build_dir") || error_exit \
			"Cannot create build directory '$build_dir'." $E_USAGE
		PDFJAM_TEMP_DIR="$(realpath -- "$build_dir")"
	fi
	export PDFJAM_TEMP_DIR ##  so that same dir is used in secondary calls
	PDFJAM_MESSAGES_FILE="$PDFJAM_TEMP_DIR"/messages.txt
	export PDFJAM_MESSAGES_FILE
	## so that secondary calls can write messages there as well
	printf "%s" "$messages" >"$PDFJAM_MESSAGES_FILE" ## initial file contents
	messages=""                                      ## we won't be using this variable again!
else
	[ -d "$PDFJAM_TEMP_DIR" ] || error_exit \
		"Temporary directory $PDFJAM_TEMP_DIR missing." $E_SOFTWARE
	PDFJAM_TEMP_DIR="$PDFJAM_TEMP_DIR/file$PDFJAM_CALL_NUMBER"
	(umask 077 && mkdir -p "$PDFJAM_TEMP_DIR")
fi
if using_non_cygwin_latex_from_cygwin; then
	PDFJAM_TEMP_DIR=$(cygpath -w "$PDFJAM_TEMP_DIR")
fi
##
##  TEMPORARY DIRECTORY ALL DONE
##
#########################################################################
##
##  HANDLING THE "--batch" OPTION
##
##  If --batch was used, we'll call pdfjam separately on each input
##  file.
##
if test "$batch" = true; then
	if test "$fileSpec" = ""; then
		error_exit "--batch was used, but no PDF/JPG/PNG source file(s) specified" \
			$E_USAGE
	fi
	if test "$inputFromStdin" = true; then
		error_exit "--batch cannot be used with input from stdin" \
			$E_USAGE
	fi
	IFS="$newline"
	for k in $fileSpec; do
		sourcePath=$(printf "%s" "$k" | sed 's/|[^|]*$//')
		pageSpec=$(printf "%s" "$k" | sed 's/.*|//')
		callNumber=$((PDFJAM_CALL_NUMBER + 1))
		prattle "--"
		prattle "Processing file ${callNumber}, '$sourcePath'..."
		prattle "Page spec is '$pageSpec'."
		sourcePath=$(enquote "$sourcePath")
		PDFJAM_EFFECTIVE_CALL="$0 $callOptions -- $sourcePath $pageSpec"
		export PDFJAM_EFFECTIVE_CALL
		PDFJAM_CALL_NUMBER=$callNumber
		export PDFJAM_CALL_NUMBER
		eval "$PDFJAM_EFFECTIVE_CALL"
		## i.e., call pdfjam again with one input file
	done
	if [ "$verbose" = "true" ]; then cat "$PDFJAM_MESSAGES_FILE" >&2; fi
	IFS=$OIFS
	exit 0
fi
##
##  END OF THE '--batch' PROCESSING
##
#########################################################################
##
##  RECORD THE EFFECTIVE CALL TO PDFJAM, FOR POSSIBLE DEBUGGING PURPOSES
##
##  Save the text of this (effective) call to pdfjam in a temporary file,
##  for later inspection if necessary.
##
##  For secondary calls, the effective call text is already made;
##  otherwise we make it here.
##
if test "$PDFJAM_CALL_NUMBER" -gt 0; then
	theCall="$PDFJAM_EFFECTIVE_CALL"
else
	filePageSpec=""
	IFS="$newline"
	for k in $fileSpec; do
		##  Last substitution on next line is needed for silly characters in
		##  file names...
		sourcePath=$(printf "%s" "$k" | sed 's/|[^|]*$//')
		sourcePath=$(enquote "$sourcePath")
		pageSpec=$(printf "%s" "$k" | sed 's/.*|//')
		filePageSpec="$filePageSpec$sourcePath $pageSpec "
	done
	IFS="$OIFS"
	theCall="$0 $callOptions -- $filePageSpec"
fi
printf "%s\n%s\n" "cd $pwd" "$theCall" >"$PDFJAM_TEMP_DIR"/call.txt
prattle "Effective call for this run of pdfjam:"
prattle "$theCall" 1
##
#########################################################################
##
##  NOW MAKE THE INPUT FILE ETC., READY FOR LATEX
##
filePageList=""  ## initialize a string to supply to \includepdfmerge
counter=0
##
##  Make symbolic link(s) to the source file(s) in the temporary dir,
##  and make the $filePageList string for input to \includepdfmerge
##
stdinUnread=true
IFS="$newline"
for k in ${fileSpec}; do
	counter=$((counter + 1))
	sourcePath=$(printf "%s" "$k" | sed 's/|[^|]*$//')
	pageSpec=$(printf "%s" "$k" | sed 's/.*|//')
	##  Check, though not exhaustively, for problems with the
	##  page spec: leading or trailing comma, double comma or
	##  double dash, alphabetic characters other than the word "last",
	##  braces not paired as {} with nothing inbetween.  A fully
	##  specified pattern for valid \includepdfmerge page spec would
	##  be better here; but life is too short...
	if printf "%s" "$pageSpec" | sed 's/last/99/g' \
		| grep '^,.*\|,$\|,,\|--\|[A-Za-z]\|{[^}]\|[^{]}' 1>/dev/null; then
		error_exit "invalid page spec $pageSpec" $E_USAGE
	fi
	case $sourcePath in
	/dev/stdin)
		uniqueName=stdin.pdf
		if test "$stdinUnread" = true; then
			if tty -s; then
				error_exit \
					"tty is connected to stdin, no PDF/JPG/PNG file found" \
					$E_NOINPUT
			fi
			cat >"$PDFJAM_TEMP_DIR/$uniqueName"
			stdinUnread=false
		fi
		;;
	*)
		pdfName=$(basename -- "$sourcePath")
		sourceDir=$(dirname -- "$sourcePath") ## zsh on Mac OS 10.5 chokes here
		cd "$sourceDir" || exit 1  ##  just to get the full path
		sourceDir=$(pwd)
		cd "$pwd" || exit 1
		sourceFullPath="$sourceDir/$pdfName"
		uniqueName="source-$counter.pdf"
		if using_non_cygwin_latex_from_cygwin; then
			cp -f "$sourceFullPath" "$PDFJAM_TEMP_DIR/$uniqueName"
		else
			ln -fs "$sourceFullPath" "$PDFJAM_TEMP_DIR/$uniqueName"
		fi
		;;
	esac
	filePageList="$filePageList,$uniqueName,$pageSpec"
done
IFS="$OIFS"
filePageList="${filePageList#,}"
if using_non_cygwin_latex_from_cygwin; then
	filePageList=$(printf %s "$filePageList" | tr \\\\ /)
fi

##
##  Finally enter build directory
##
cd "$PDFJAM_TEMP_DIR" || exit 1

##
##  Do the pdfinfo stuff (if relevant)...
##
select_pdfinfo() {
	##  pdfinfo fields are 17 chars wide.
	##  This implementation preserves leading spaces
	printf %s "$2" | awk "/^$(printf %-17s "$1:")/{print substr(\$0,18)}"
}
if test -n "$keepinfo"; then
	prattle "Calling ${pdfinfo}..."
	PDFinfo=$(pdfinfo -enc UTF-8 "$uniqueName")
	pdftitl=$(select_pdfinfo 'Title'    "$PDFinfo")
	pdfauth=$(select_pdfinfo 'Author'   "$PDFinfo")
	pdfsubj=$(select_pdfinfo 'Subject'  "$PDFinfo")
	pdfkeyw=$(select_pdfinfo 'Keywords' "$PDFinfo")
fi

echo_iconv_from_enc() {
	printf %s "$1" | "$iconv" -f "$enc" -t UTF-8
}
if test -n "${pdftitle+X}"; then
	pdftitl=$(echo_iconv_from_enc "${pdftitle-}")
fi
if test -n "${pdfauthor+X}"; then
	pdfauth=$(echo_iconv_from_enc "${pdfauthor-}")
fi
if test -n "${pdfsubject+X}"; then
	pdfsubj=$(echo_iconv_from_enc "${pdfsubject-}")
fi
if test -n "${pdfkeywords+X}"; then
	pdfkeyw=$(echo_iconv_from_enc "${pdfkeywords-}")
fi

echo_hex_iconv_utf16be() {
	printf '%s' "$1" \
		| "$iconv" -f UTF-8 -t UTF-16BE \
		| od -An -v -tx1 \
		| tr -d '[:space:]'
}
addto_pdfinfo() {
	if [ -n "$2" ]; then
		## Convert to PDF string and append
		raw_pdfinfo="$raw_pdfinfo
    /$1 <feff$(echo_hex_iconv_utf16be "$2")> %"
	fi
}
raw_pdfinfo=
addto_pdfinfo Title    "$pdftitl"
addto_pdfinfo Author   "$pdfauth"
addto_pdfinfo Subject  "$pdfsubj"
addto_pdfinfo Keywords "$pdfkeyw"
if [ -n "$raw_pdfinfo" ]; then
	raw_pdfinfo='
\ifdefined\luatexversion% LuaLaTeX
  \protected\def\pdfinfo{\pdfextension info}
\fi
\ifdefined\XeTeXversion% XeLaTeX
  \protected\def\pdfinfo#1{\AddToHook{shipout/firstpage}{\special{pdf:docinfo << #1 >>}}}
\fi
\ifdefined\pdfinfo%
  \pdfinfo{%'"$raw_pdfinfo"'
  }%
\fi'
fi

## Apply $pagecolor if set
if [ -n "$pagecolor" ]; then
	colorcode="
\\usepackage{color}
\\definecolor{bgclr}{RGB}{$pagecolor}
\\pagecolor{bgclr}"
else
	colorcode=
fi
##
##  Now set up the LaTeX file
##
fileName="$(pwd)/a"
(cat <<EndTemplate
\batchmode
\documentclass[$documentOptions]{article}$colorcode
\usepackage[$papersize]{geometry}
\usepackage[utf8]{inputenc}$raw_pdfinfo
\usepackage{pdfpages}$other_edge$preamble
\begin{document}
\includepdfmerge[$miscOptions]{$filePageList}
\end{document}
EndTemplate
) >"$fileName.tex"
##
##  INPUT FILES ARE ALL READY
##
#########################################################################
##
##  RUN LATEX AND COPY THE RESULTING PDF FILE
##
if [ "$runs" -eq 1 ] ;
then prattle "Calling ${latex}..."
else prattle "Calling ${latex} $runs times..."
fi
failureText=\
"FAILED.
The call to $latex resulted in an error."
if [ -n "$tidy" ]; then
	failureText="$failureText
Rerun with '--no-tidy' (or '--build-dir PATH') to diagnose the problem."
else
	failureText="$failureText
You can examine the log file at
        $fileName.log
to try to diagnose the problem."
fi
i=1
while [ "$i" -le "$runs" ]; do
	"$latex" "$fileName.tex" >"$fileName.msgs" || {
		prattle "$failureText"
		error_exit "Run $i: Output file not written" $E_SOFTWARE
	}
	i=$((i + 1))
done
cd "$pwd" || exit 1
if test -f "$fileName".pdf; then ## if LaTeX didn't choke
	##  Checks on output file path:
	if test -d "$outFile"; then ## outfile is a directory
		if test ! -w "$outFile"; then
			error_exit \
				"FAILED: no write permission on ${outFile}." \
				$E_OSFILE
		fi
		separator="-"
		if test "$pageSpec" != "-"; then
			separator=-"$pageSpec"-
		fi
		outFile=$(printf "%s" "$outFile" | sed 's/\/$//') ## delete any trailing slash
		pdfName=$(basename -- "$sourcePath")
		pdfName=$(printf "%s" "$pdfName" |
			sed 's/\.[pP][dD][fF]$//') ## strip extension
		pdfName="$pdfName$separator$suffix".pdf
		outFile="$outFile/$pdfName"
	fi
fi
if test -f "$outFile" && test ! -w "$outFile"; then
	## file exists and we can't over-write it
	error_exit "no write permission at ${outFile}" $E_CANTCREATE
fi
#fileSize=$(wc -c < "$fileName.pdf" | sed 's/^\ *//')
## Avoid explicit output to /dev/stdout.
if test "$outFile" = "/dev/stdout" \
	&& cat "$fileName".pdf 2> /dev/null \
	|| cat "$fileName".pdf > "$outFile" 2>/dev/null
then prattle "Finished.  Output was written to '${outFile}'."
else error_exit "cannot write output at ${outFile}" $E_CANTCREATE
fi
if [ "$PDFJAM_CALL_NUMBER" = "0" ] && [ "$verbose" = "true" ]; then
	cat "$PDFJAM_MESSAGES_FILE" >&2
fi
exit 0
##
##  END
##
#########################################################################
