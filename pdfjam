#!/usr/bin/env texlua
version="N.NN"
kpse.set_program_name("kpsewhich")
require "lualibs"

configpath = {"/etc", "/usr/share/etc", "/usr/local/share", "/usr/local/etc"}
home = os.getenv("HOME")

do
	local a = os.type == "windows" and os.getenv("AppData")
		or os.getenv("XDG_CONFIG_HOME")
		or home and file.join(home, ".config")
	if a then table.insert(configpath, a) end
end

-- utilities --

function identity(x) return x end

function coalesce(...) -- return first non-nil
	for i = 1, select("#", ...) do
		if select(i, ...) ~= nil then return (select(i, ...)) end
	end
end

function debugprint(s, ...)
	if not DEBUG then return end
	io.stderr:write(string.formatters[s.."\n"](...))
end

-- string utilities --

function startswith(s, a) return string.sub(s, 1, #a) == a end

function replace(s, a, b)
	local i, j = string.find(s, a, 1, true)
	assert(i~=nil)
	return string.sub(s, 1, i-1) .. b .. string.sub(s, j+1)
end

function embrace(s)
	if string.find(s, "[],=]") and not
		(string.sub(s, 1, 1) == "{" and string.sub(s, #s) == "}") then
		return "{" .. s .. "}"
	else return s
	end
end

function unbrace(s)
	if string.sub(s, 1, 1) == "{" and string.sub(s, #s) == "}" then
		return string.sub(s, 2, #s-1)
	else return s
	end
end

function enquote(s)
	return "'" .. string.gsub(s, "'", "'\\''") .. "'"
end

-- file utilities --

function rmdir(t) os.spawn({"rm", "-rf", t[1]}) end
function mkdir(d)
	d, success = dir.makedirs(d)
	if not success then err("Could not create directory " .. d) end
	return file.collapsepath(d, true)
end
function gcdir(d)
	local t = {d}
	setmetatable(t, {__gc = rmdir})
	return t
end
function providedir(d, tidy)
	if d then
		return mkdir(d)
	else
		d = os.tmpname()
		os.remove(d)
		return mkdir(d), tidy and gcdir(d) or nil
	end
end
slash = os.type == "windows" and "\\" or "/"
function ismkdir(d)
	if lfs.isdir(d) then
	elseif string.sub(d, #d) == slash then mkdir(d)
	else return end
	return d
end

local lookup = os.type == "windows" and "where.exe" or "command -v"
function executable(exe)
	exe = enquote(exe)
	return io.popen(lookup .. " " .. exe):read() and exe
end
function popen(exe, ...)
	exe = executable(exe)
	return exe and io.popen(exe .. table.concat({"", ...}, " "))
end
function execute(exe, ...)
	exe = executable(exe)
	return exe and os.execute(exe .. table.concat({"", ...}, " "))
end

-- option parser

function getopt(arg)
	local vanilla
	for _, w in ipairs(arg) do
		if w == "--" then break
		elseif w == "--vanilla" then vanilla = true
		elseif w == "--no-vanilla" then vanilla = nil
		end
	end
	local options, t = define_options()
	local a
	if not vanilla then
		local p = ConfigParser:new({options = options, t = t})
		for _, d in ipairs(configpath) do p:parse(file.join(d, "pdfjam.conf")) end
		if home then p:parse(file.join(home, ".pdfjam.conf")) end
		t = p.t
	end
	parser = Parser:new({
		options = options,
		short_options = short_options,
		t = t,
	})
	a, t = parser:parse(arg)
	t.vanilla = nil
	debugprint("args: %,T\nopts: %T", a, t)
	return Interpreter:new({a=a, t=t, options=options})
end

Parser = {}
function Parser:new(obj)
	local obj = obj or {}
	obj.options = obj.options or {}
	obj.short_options = obj.short_options or {}
	obj.t = obj.t or {}
	self.__index = self
	setmetatable(obj, self)
	return obj
end

function Parser:parse(args)
	self._args = args
	self.a = {}
	self.i = 1
	while self.i <= #args do
		self:parse_word(args[self.i])
		self.i = self.i + 1
	end
	return self.a, self.t
end

function Parser:parse_word(word)
	if not self.dash_seen and word == "--" then
		self.dash_seen = true
	elseif not self.dash_seen and string.sub(word, 1, 2) == "--" then
		self:parse_long_option(string.sub(word, 3))
	elseif self.dash_seen or string.sub(word, 1, 1) ~= "-"
		or not self:parse_short_options(word) then
		self:parse_positional_argument(word)
	end
end

function Parser:parse_long_option(a)
	self:set_option(lpeg.match(lpeg.splitat("=", true), a))
end

function Parser:parse_short_options(word)
	self.j = 2
	local s = string.sub(word, 2, 2)
	if not self.short_options[s] then return false end
	while s ~= "" do
		local a = self.short_options[s]
		if a then
			self:set_option(a)
		else
			self:error("unknown option -" .. s)
		end
		self.j = self.j + 1
		s = string.sub(word, self.j, self.j)
	end
	self.j = nil
	return true
end

function Parser:set_option(a, v)
	if string.sub(a, 1, 3) == "no-" then
		self:unset(string.sub(a, 4))
		if v then self:error("unsetting expects no value") end
		return
	end
	o = self.options[a] or pdfpagesopt
	if type(o) == "string" then -- alias
		return self:set_option(o, v)
	end
	assert(type(o) == "table")
	if o.argument == false then
		if v then self:error("no argument allowed") end
	else
		v = v or self:argument(o.argument) or self:error("argument required")
	end
	local value, err = o.func(v, a, self.t)
	self:error(err)
	self:set(a, value)
end

function Parser:parse_positional_argument(word)
	if self.last_positional_argument and self.last_positional_argument < self.i - 1 then
		table.insert(self.a, false)
	end
	table.insert(self.a, word)
	self.last_positional_argument = self.i
end

function Parser:get(a) return self.t[a] end
function Parser:set(a, value) if value ~= nil then self.t[a] = value end end
function Parser:unset(a) self.t[a] = nil end
function Parser:word(n) return self._args[self.i + (n or 0)] end

-- Read argument `w`.
-- If `options` is given, only read `w` if `options[w]` exists.
-- If `w` could be an option (starts with -), throw error.
function Parser:argument(options)
	assert(options==nil or type(options) == "table")
	local w
	if self.j then
		w = string.sub(self:word(), self.j+1)
		if options and not options[w] then return end
		if w ~= "" then self.j = #self:word() return w end
	end
	w = self:word(1)
	if options and not options[w] then return end
	if not w then
		self:error("argument required, but end of command line reached")
	elseif string.sub(w, 1, 2) == "--"
		or string.sub(w, 1, 1) == "-" and self.short_options[string.sub(w, 2, 2)] then
		self:error("argument required, but the following word '" .. w
			.. "' seems to be an option.\n\n\z
			Tip: For supplying an argument starting with '-' use " .. self:word()
			.. (string.sub(self:word(), 2, 2) == "-" and "=" or "") .. w .. " instead.")
	end
	self.i = self.i + 1
	return w
end

function Parser:error(s, ...)
	if not s then return end
	collectgarbage()
	error(string.format("Error while parsing %s: " .. s .. ".", self:word(), ...))
end

function err(s, ...)
	if not s then return end
	collectgarbage()
	error(string.format("Error: " .. s .. ".", ...))
end
function warn(s, ...)
	if not s then return end
	print(string.format("Warning: " .. s, ...))
end

ConfigParser = Parser:new()
do
	local spaces = lpeg.patterns.spacer^0
	local rest = lpeg.P(1)^0
	local key = lpeg.C((1 - lpeg.S(" \t\f\v="))^1)
	local value = lpeg.C(rest)
	local entry = key * spaces * ("=" * spaces * value)^-1
	local comment = "#" * rest * lpeg.Cc(false)
	local line = spaces * (comment + entry) * -1
	function ConfigParser:parse(file)
		local f = io.open(file)
		if f then
			self.file = file -- for error messages
			for l in f:lines() do
				self.current = l -- for error messages
				self:parse_word(lpeg.match(line, l))
			end
			f:close()
		end
		return self.t
	end
end
function ConfigParser:parse_word(k, v)
	if k == nil then self:error("illegal syntax")
	elseif k then return self:set_option(k, v) end
end
function ConfigParser:argument(optional)
	if optional then self:error("argument needed") end
end
function ConfigParser:error(s, ...)
	if not s then return end
	print(string.format("Problem while parsing %s in line '%s': " .. s .. ".", self.file, self.current, ...))
end

Interpreter = {}
function Interpreter:new(obj)
	local obj = obj or {}
	obj.t = obj.t or {}
	obj.options = obj.options or {}
	self.__index = self
	setmetatable(obj, self)
	return obj
end

function Interpreter:pop(a)
	local v = self.t[a]
	if v ~= nil then self.t[a] = nil return v end
end
function Interpreter:retrieve(a)
	local v = self:pop(a)
	if v then
		local f = self.options[a] and self.options[a].retrieve
		if f then return f(v, self.t) end
		return v == true and a or a .. "=" .. embrace(v)
	else return ""
	end
end

function Interpreter:list(...)
	local r
	for _, a in ipairs({...}) do
		local x = self:retrieve(a)
		if x and x ~= "" then
			r = r and r .. "," .. x or x
		end
	end
	return r or ""
end

function Interpreter:pdfpagesoptions()
	local r = ""
	for i, a in recall_numbered do
		r = r .. "," .. self:retrieve(a)
	end
	return string.sub(r, 2)
end

-- pdfjam options

do
	local pos = {}
	function numbered(v, a, t)
		if t and t[a] then table.remove(pos, table.contains(pos, a)) end
		table.insert(pos, a)
		return v
	end
	function recall_numbered(_, i)
		i = (i or 0) + 1
		if pos[i] then return i, pos[i]
		else debugprint("pdfpagesoptsorder: %,T", pos) return nil end
	end
end

normalopt = {func = identity}
pdfpagesopt = {func = numbered}
flagopt = {
	argument = false,
	func = function() return true end
}
paperopt = {
	argument = false,
	func = function(_, a, t) t.paper = a t.papersize = nil end
}

bool_prose = {["true"]="true", yes="true", on="true", ["false"]="false", no="false", off="false"}
boolopt = {
	argument = bool_prose,
	func = function(v, a, t)
		if not v then return numbered(true, a, t) end
		local b = bool_prose[v]
		if b == nil then
			return nil, "Cannot interpret '" .. v .. "' as boolean value.\n\n\z
			Tip: Accepted values are 'true', 'yes' and 'on', respectively 'false', 'no' and 'off'"
		else
			return numbered(b, a, t)
		end
	end
}

function define_options()
	local options = {}
	local bool_options = {
		"flip-other-edge", "frame", "column", "columnstrict",
		"openright", "openrighteach", "turn", "noautoscale", "fitpaper",
		"reflect", "booklet", "booklet*", "rotateoversize",
		"link", "thread", "keepaspectratio", "clip", "draft", "interpolate",
		"doublepages", "doublepagestwist", "doublepagestwistodd",
		"doublepagestwist*", "doublepagestwistodd*"
	}
	local normal_options = {"builddir", "outfile", "suffix", "latex", "iconv",
		"enc", "pdftitle", "pdfauthor", "pdfsubject", "pdfkeywords", runs
	}
	local flag_options = {"vanilla", "quiet", "tidy", "keepinfo",
		"landscape", "twoside", "checkfiles", "batch"
	}
	local paper_options = {
		"a0paper","a1paper","a2paper","a3paper","a4paper","a5paper","a6paper",
		"b0paper","b1paper","b2paper","b3paper","b4paper","b5paper","b6paper",
		"c0paper","c1paper","c2paper","c3paper","c4paper","c5paper","c6paper",
		"ansiapaper","ansibpaper","ansicpaper","ansidpaper","ansiepaper",
		"letterpaper","legalpaper","executivepaper",
		"b0j","b1j","b2j","b3j","b4j","b5j","b6j"
	}
	local paper_hash = table.tohash(paper_options)
	local mode_options = {help = show_help, version = show_version,
		configpath = show_configpath
	}
	for _, o in ipairs(bool_options) do options[o] = boolopt end
	for _, o in ipairs(normal_options) do options[o] = normalopt end
	for _, o in ipairs(flag_options) do options[o] = flagopt end
	for _, o in ipairs(paper_options) do options[o] = paperopt end
	for o, f in pairs(mode_options) do options[o] = {argument = false, func = f} end
	function to_paper(a)
		a = string.lower(a)
		return paper_hash[a] and a or paper_hash[a .. "paper"] and a .. "paper"
	end
	options.paper = {
		func = function(v, _, t)
			t.papersize = nil
			local paper = to_paper(v)
			if paper then return paper
			else return nil, "Unknown paper format '" .. v .. "'"
			end
		end,
		retrieve = identity
	}
	options.papersize = {
		func = function(v, _, t)
			t.paper = nil
			v = unbrace(v)
			h, h_unit, w, w_unit = string.match(v, "^(%d+)(%l*),(%d+)(%l*)$")
			if not h then return nil, "wrong syntax for papersize" end
			h_unit = h_unit ~= "" and h_unit or "bp"
			w_unit = w_unit ~= "" and w_unit or "bp"
			return {h .. h_unit, w .. w_unit}
		end,
		retrieve = function(v, t)
			if t.landscape then v = {v[2], v[1]} end
			return "papersize={" .. v[1] .. "," .. v[2] .. "}"
		end
	}
	options.preamble = {
		func = function(v, _, t)
			t.preamble = (t.preamble or "") .. "\n" .. v
		end,
		retrieve = identity
	}
	options.pagecolor = {
		func = identity,
		retrieve = function(v)
			return "\n\z
				\\usepackage{color}\n\z
				\\definecolor{bgclr}{RGB}{"..v.."}\n\z
				\\pagecolor{bgclr}"
		end
	}
	options.otheredge = table.fastcopy(flagopt) -- copy before manipulating
	options.otheredge.retrieve = function(v)
		return "\n"..[[{\makeatletter\AddToHook{shipout/before}{\ifodd\c@page\pdfpageattr{/Rotate 180}\fi}}]]
	end
	options.longedge = "otheredge"
	options.shortedge = "no-otheredge"

	local paper_pattern = lpeg.C((1 - lpeg.P":")^1) * ": "
		* lpeg.C(lpeg.R"09"^1) * "x" * lpeg.C(lpeg.R"09"^1)
		* " " * lpeg.C(lpeg.R"az"^1) * -1
	local paperconf_pattern = lpeg.C(lpeg.patterns.number)
		* " " * lpeg.C(lpeg.patterns.number)
	local function default_paper()
		local o = popen("paper")
		if o then
			local p, x, y, u = lpeg.match(paper_pattern, o:read())
			if not u then
				warn("The `paper` program seems not to be working; not using it")
			else
				local paper = to_paper(p)
				if paper then return paper
				else return nil, {x .. u, y .. u} end
			end
		end
		o = popen("paperconf")
		if not o then return "a4paper" end
		local paper = to_paper(o:read())
		if paper then return paper end
		o = popen("paperconf", "-s")
		if not o then return "a4paper" end
		local x, y = lpeg.match(paperconf_pattern, o:read())
		return nil, {x .. "bp", y .. "bp"}
	end

	local initial = {
		tidy = true,
		outfile = ".",
		suffix = "pdfjam",
		runs = 1,
		latex = "pdflatex",
		latexopts = "-interaction batchmode",
		pdfinfo = "pdfinfo",
		iconv = "iconv",
		checkfiles = magic_file(arg[0]) == "a texlua script",
		pages = "-"
	}
	initial.paper, initial.papersize = default_paper()
	return options, initial
end

-- Used: [Vhoq]. Used in pagespec: [-,0-9l].
short_options = {h="help", V="version", q="quiet", o="outfile"}

function exit(code) collectgarbage() os.exit(code, true) end
function show_help(_, _, t) print("This is how to use it.") table.print(t) exit() end
function show_version() print("pdfjam version "..version) exit() end
function show_configpath() print("configpath is ...") exit() end

--- pdfinfo ---
do
local pdfkeys = {"Title", "Author", "Subject", "Keywords"}

function pop_pdfinfo(x)
	local iconv, enc = x:pop"iconv", x:pop"enc"
	local to_utf16_be = utf.utf8_to_utf16_be
	if enc then
		local iconv_opts = "-f " .. enc .. " -t UTF-16BE -- iconv.txt"
		to_utf16_be = function(s)
			local f = io.savedata("iconv.txt", s)
			local p = popen(iconv, iconv_opts)
			local result = "\xfe\xff" .. p:read("a")
			return result
		end
	end
	local info = {}
	for _, k in ipairs(pdfkeys) do
		local v = x:pop("pdf" .. string.lower(k))
		if v then info[k] = to_utf16_be(v) end
	end
	return info
end

local labels = {}
for _, a in ipairs(pdfkeys) do
	labels[string.format("%-17s", a..":")] = a
end
function read_pdfinfo(pdfinfo, f)
	local info = {}
	-- Note: There does not seem to be the choice of UTF-16BE.
	for l in popen(pdfinfo, "-enc UTF-8 --", f):lines() do
		local k = labels[string.sub(l, 1, 17)]
		if k and #l > 17 then info[k] = utf.utf8_to_utf16_be(string.sub(l, 18)) end
	end
	return info
end

local pdfinfo_template = "\n" .. [[
\ifdefined\luatexversion
	\protected\def\pdfinfo{\pdfextension info}
\fi
\ifdefined\XeTeXversion
	\protected\def\pdfinfo#1{\AddToHook{shipout/firstpage}{\special{pdf:docinfo << #1 >>}}}
\fi
\ifdefined\pdfinfo
	\pdfinfo{%]]
local pdfinfo_template_end = "\n\t}\n\\fi"

function pdfinfo_code(info)
	local r = ""
	if next(info) then
		r = pdfinfo_template
		for _, k in ipairs(pdfkeys) do
			if info[k] and info[k] ~= "\xfe\xff" then
				r = r .. "\n\t\t/" .. k .. " <" .. string.tohex(info[k]) .. ">"
			end
		end
		r = r .. pdfinfo_template_end
	end
	return r
end
end -- /pdfinfo

function merge_pdfinfo(overwrite, pdfinfo, file)
	if pdfinfo and file then
		local info = read_pdfinfo(pdfinfo, file)
		table.merge(info, overwrite)
		return info
	else return overwrite
	end
end

--- file utility ---

function magic_file(f)
	-- Note: 19 = #"PostScript document"
	local ans = popen("file", "-Lb", enquote(file.collapsepath(f, true))):read(19)
	return string.split(ans, ",")[1]
end

do
	local magic_names = {
		["PDF document"]="pdf", ["PostScript document"]="eps",
		["JPEG image data"]="jpg", ["PNG image data"]="png"
	}
	local ext_names = {pdf="pdf", eps="eps", jpg="jpg", png="png",
		ps="eps", jpeg="jpg"}

	function get_extension(f, checkfiles)
		if checkfiles then
			return magic_names[magic_file(f)]
		else
			return ext_names[string.lower(file.extname(f))]
		end
	end
end

function new_name(f, checkfiles)
	local ext = get_extension(f, checkfiles) or "pdf"
	return file.addsuffix(file.robustname(file.basename(f)), ext, ext), ext
end

--- page specs ---

do
	local page = "last" + lpeg.R"09" ^ 0 -- any or no page
	local range = page * ("-" * page) ^ -1 -- any or no page range (the latter being an implicit empty page)
	local part = "{}" + range -- page range or implicit or explicit empty page
	local spec = part * ("," * part) ^ 0 * -1 -- complete page spec
	function is_valid_pagespec(word)
		return lpeg.match(spec, word) ~= nil
	end
end

--- file and pagespec list ---

function out_name(out, last_in, suffix)
	out = out or "."
	local dir = "."
	if ismkdir(out) then
		dir = out
		local name = file.nameonly(last_in) .. (suffix and "-" .. suffix or "") .. ".pdf"
	elseif file.is_rootbased_path(out) then return out
	else name = out
	end
	dir = file.collapsepath(dir, true) -- bug when dir contains :
	return file.join(dir, name)
end

function out_names(out, files, suffix)
	out = out or "."
	if not ismkdir(out) and files[2] then err("Output must go to directory in batch mode") end
	suffix = suffix and "-"..suffix or ""
	local dir = file.collapsepath(out, true) -- bug when out contains :
	local r = {}
	for _, name in ipairs(files) do
		table.insert(r, file.join(dir, file.nameonly(name) .. suffix .. ".pdf"))
	end
	return r
end

function make_filepagelist(args, d, batch, checkfiles)
	local filepagelist, l = {}, {}
	local last_in, last_in_renamed
	local add_file, add_pagespec
	if batch then
		function add_pagespec(ps)
			for _, a in ipairs(l) do table.insert(filepagelist, {a, ps}) end
			l = {}
		end
		local i = 0
		function add_file(a)
			local b = new_name(a, checkfiles)
			i = i + 1
			mkdir(file.join(d, i))
			file.copy(a, file.join(d, i, b))
			table.insert(l, b)
		end
	else
		function add_pagespec(ps)
			for _, a in ipairs(l) do
				table.insert(filepagelist, a)
				table.insert(filepagelist, ps)
			end
			l = {}
		end
		local names = {["a.pdf"]=true}
		local function robustname(a)
			local b, ext = new_name(a, checkfiles)
			if names[b] then
				local ext, i = "."..ext, 0
				local c = string.sub(b, 1, #b-#ext).."+"
				repeat i=i+1 b = c .. i .. ext until not names[b]
			end
			names[b] = true
			return b
		end
		function add_file(a)
			last_in, last_in_renamed = a, robustname(a)
			file.copy(a, file.join(d, last_in_renamed))
			table.insert(l, last_in_renamed)
		end
	end
	local cases = { -- binary coded index
		"Input file expected, but '%s' not even exists in your file system",
		"Input file or pagespec expected, but '%s' neither exists in your file system nor is it a pagespec",
		"The argument '%s' is a valid pagespec but a valid PDF/EPS/JPG/PNG file was expected",
		add_pagespec,
		"The argument '%s' is a valid path but not a valid PDF/EPS/JPG/PNG file",
		"The argument '%s' is a valid path but not a valid PDF/EPS/JPG/PNG file or pagespec",
		"The argument '%s' is both a valid path and a pagespec but a valid PDF/EPS/JPG/PNG file was expected",
		add_pagespec,
		add_file,
		add_file,
		{add_file, "Dubious argument '%s' interpreted as file due to its position.\n\nTip: Write './%s' for extra clarity"},
		{add_pagespec, "Ambiguous argument '%s' interpreted as pagespec. If you meant the file, please write './%s' instead"},
	}
	local function add_argument(a)
		local valid = io.exists(a) and ((not checkfiles or get_extension(a, true)) and 8 or 4) or 0
		local pagespec = is_valid_pagespec(a) and 2 or 0
		local awaited = next(l) and 1 or 0
		local c = cases[valid + pagespec + awaited + 1]
		if type(c) == "function" then c(a)
		elseif type(c) == "string" then err(c, a)
		else c[1](a) warn(c[2], a, a)
		end
	end
	for _, a in ipairs(args) do
		if a == false then add_pagespec()
		else add_argument(a)
		end
	end
	add_pagespec()
	if not next(filepagelist) then
		local a = file.join(d, "stdin")
		local s = io.read("a")
		if s and s ~= "" then io.savedata(a, s)
		else err("Either an input file must be given or there must be input from stdin")
		end
		if checkfiles and not get_extension(a, checkfiles) then err("No input file given and stdin is no valid input") end
		add_file(a)
		add_pagespec()
	end
	return filepagelist, last_in, last_in_renamed
end

--- main ---

template = [[
\documentclass[$documentoptions]{article}$colorcode
\usepackage[$geometryoptions]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{pdfpages}$rawinfo$otheredge$preamble
\begin{document}
\includepdf$merge[$pages$comma$options]{$filepagelist}
\end{document}
]]
function run(tab, d, outfile, infofile)
	assert(lfs.chdir(d) or print(d))
	tab.rawinfo = pdfinfo_code(merge_pdfinfo(tab.info, tab.pdfinfo, infofile))
	tab.comma = tab.pages ~= "" and tab.options ~= "" and "," or ""
	debugprint("Running %s in %s to produce %s using %T", tab.latex, lfs.currentdir(), outfile, tab)
	local pattern = lpeg.Cs((lpeg.P"$" * lpeg.C(lpeg.R"az" ^ 1) / tab + 1) ^ 0)
	local content = pattern:match(template)
	io.savedata("a.tex", content)
	for _ = 1, tab.runs do execute(tab.latex, tab.latexopts, "a.tex", ">/dev/null") end
	file.copy("a.pdf", outfile)
end

function main(args)
	args = args or arg
	local x = getopt(args)
	local batch, outfile, suffix = x:pop"batch", x:pop"outfile", x:pop"suffix"

	local tab = {
		latex = x:pop"latex",
		latexopts = x:pop"latexopts" or "",
		pdfinfo = x:pop"pdfinfo",
		info = pop_pdfinfo(x),
		runs = tonumber(x:pop"runs"),
		geometryoptions = x:retrieve"papersize", -- before `landscape`
		documentoptions = x:list("paper", "landscape", "twoside"),
		colorcode = x:retrieve"pagecolor",
		otheredge = x:retrieve"otheredge",
		preamble = x:retrieve"preamble",
		merge = "merge",
		pages = x:retrieve"pages",
		options = x:pdfpagesoptions(),
		-- `rawinfo`, `comma` and `filepagelist` set later
	}
	if not x:pop"keepinfo" then tab.pdfinfo = nil end
	if not (tab.runs and tab.runs > 0) then err("The number of runs must be at least 1") end

	local d, gc_dummy = providedir(x:pop"builddir", x:pop"tidy")

	local filepagelist, last_in, last_in_renamed = make_filepagelist(x.a, d, batch, x:pop"checkfiles")

	assert(not next(x.t) or table.print(x.t))

	if not batch then
		local outfile = out_name(outfile, last_in, suffix)
		tab.merge = "merge"
		tab.filepagelist = table.concat(filepagelist, ",")
		run(tab, d, outfile, last_in_renamed)
	else
		local outfiles = out_names(outfile, x.a, suffix)
		for i, fp in ipairs(filepagelist) do
			local f, pagespec = fp[1], fp[2]
			tab.filepagelist = f
			if pagespec then tab.pages = "pages=" .. embrace(pagespec) end
			run(tab, file.join(d, i), outfiles[i], f)
		end
	end
end

DEBUG = true
success, msg = xpcall(main, debug.traceback)

collectgarbage()
if not success then
	print(msg)
	exit(1)
end
